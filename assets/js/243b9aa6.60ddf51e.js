"use strict";(self.webpackChunkreact_native_website=self.webpackChunkreact_native_website||[]).push([[3142],{35318:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return f}});var n=r(27378);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(r),f=a,m=d["".concat(c,".").concat(f)]||d[f]||u[f]||i;return r?n.createElement(m,o(o({ref:t},p),{},{components:r})):n.createElement(m,o({ref:t},p))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=r[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},30499:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return d},contentTitle:function(){return f},metadata:function(){return m},toc:function(){return h},default:function(){return v}});var n=r(35318),a=Object.defineProperty,i=Object.defineProperties,o=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable,p=(e,t,r)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,u=(e,t)=>{for(var r in t||(t={}))c.call(t,r)&&p(e,r,t[r]);if(s)for(var r of s(t))l.call(t,r)&&p(e,r,t[r]);return e};const d={id:"fabric-renderer",title:"Fabric"},f=void 0,m={unversionedId:"fabric-renderer",id:"fabric-renderer",title:"Fabric",description:"Fabric is React Native's new rendering system, a conceptual evolution of the legacy render system. The core principles are to unify more render logic in C++, improve interoperability with host platforms, and to unlock new capabilities for React Native. Development began in 2018 and in 2021, React Native in the Facebook app is backed by the new renderer.",source:"@site/architecture/fabric-renderer.md",sourceDirName:".",slug:"/fabric-renderer",permalink:"/architecture/fabric-renderer",editUrl:"https://github.com/facebook/react-native-website/blob/master/website/architecture/fabric-renderer.md",tags:[],version:"current",lastUpdatedAt:1648760516,formattedLastUpdatedAt:"4/1/2022",frontMatter:{id:"fabric-renderer",title:"Fabric"},sidebar:"architecture",previous:{title:"Architecture Overview",permalink:"/architecture/overview"},next:{title:"Render, Commit, and Mount",permalink:"/architecture/render-pipeline"}},h=[{value:"Motivations and Benefits of the new renderer",id:"motivations-and-benefits-of-the-new-renderer",children:[],level:2}],b={toc:h};function v(e){var t,r=e,{components:a}=r,p=((e,t)=>{var r={};for(var n in e)c.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&s)for(var n of s(e))t.indexOf(n)<0&&l.call(e,n)&&(r[n]=e[n]);return r})(r,["components"]);return(0,n.kt)("wrapper",(t=u(u({},b),p),i(t,o({components:a,mdxType:"MDXLayout"}))),(0,n.kt)("p",null,"Fabric is React Native's new rendering system, a conceptual evolution of the legacy render system. The core principles are to unify more render logic in C++, improve interoperability with ",(0,n.kt)("a",u({parentName:"p"},{href:"/architecture/glossary#host-platform"}),"host platforms"),", and to unlock new capabilities for React Native. Development began in 2018 and in 2021, React Native in the Facebook app is backed by the new renderer."),(0,n.kt)("p",null,"This documentation provides an overview of the ",(0,n.kt)("a",u({parentName:"p"},{href:"/architecture/glossary#fabric-render"}),"new renderer")," and its concepts. It avoids platform specifics and doesn\u2019t contain any code snippets or pointers. This documentation covers key concepts, motivation, benefits, and an overview of the render pipeline in different scenarios."),(0,n.kt)("h2",u({},{id:"motivations-and-benefits-of-the-new-renderer"}),"Motivations and Benefits of the new renderer"),(0,n.kt)("p",null,"The render architecture was created to unlock better user experiences that weren\u2019t possible with the legacy architecture. Some examples include:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"With improved interoperability between ",(0,n.kt)("a",u({parentName:"li"},{href:"/architecture/glossary#host-view-tree-and-host-view"}),"host views")," and React views, the renderer is able to measure and render React surfaces synchronously. In the legacy architecture, React Native layout was asynchronous which led to a layout \u201cjump\u201d issue when embedding a React Native rendered view in a ",(0,n.kt)("em",{parentName:"li"},"host view"),"."),(0,n.kt)("li",{parentName:"ul"},"With support of multi-priority and synchronous events, the renderer can prioritize certain user interactions to ensure they are handled in a timely manner."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",u({parentName:"li"},{href:"https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}),"Integration with React Suspense")," which allows for more intuitive design of data fetching in React apps."),(0,n.kt)("li",{parentName:"ul"},"Enable React ",(0,n.kt)("a",u({parentName:"li"},{href:"https://github.com/reactwg/react-18/discussions/4"}),"Concurrent Features")," on React Native."),(0,n.kt)("li",{parentName:"ul"},"Easier to implement server side rendering for React Native.")),(0,n.kt)("p",null,"The new architecture also provides benefits in code quality, performance, and extensibility:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Type safety:")," code generation to ensure type safety across the JS and ",(0,n.kt)("a",u({parentName:"li"},{href:"/architecture/glossary#host-platform"}),"host platforms"),". The code generation uses JavaScript component declarations as source of truth to generate C++ structs to hold the props. Mismatch between JavaScript and host component props triggers a build error."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Shared C++ core"),": the renderer is implemented in C++ and the core is shared among platforms. This increases consistency and makes it easier to adopt React Native on new platforms."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Better Host Platform Interoperability"),": Synchronous and thread-safe layout calculation improves user experiences when embedding host components into React Native, which means easier integration with host platform frameworks that require synchronous APIs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Improved Performance"),": With the new cross-platform implementation of the renderer system, every platform benefits from performance improvements that may have been motivated by limitations of one platform. For example, view flattening was originally a performance solution for Android and is now provided by default on both Android and iOS."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Consistency"),": The new render system is cross-platform, it is easier to keep consistency among different platforms."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Faster Startup"),": Host components are lazily initialized by default."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Less serialization of data between JS and host platform"),": React used to transfer data between JavaScript and ",(0,n.kt)("em",{parentName:"li"},"host platform")," as serialized JSON. The new renderer improves the transfer of data by accessing JavaScript values directly using ",(0,n.kt)("a",u({parentName:"li"},{href:"/architecture/glossary#javascript-interfaces-jsi"}),"JavaScript Interfaces (JSI)"),".")))}v.isMDXComponent=!0}}]);