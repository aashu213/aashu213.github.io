"use strict";(self.webpackChunkreact_native_website=self.webpackChunkreact_native_website||[]).push([[83686],{35318:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(27378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},31266:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return d},contentTitle:function(){return m},metadata:function(){return h},assets:function(){return f},toc:function(){return y},default:function(){return g}});var a=n(35318),r=Object.defineProperty,i=Object.defineProperties,o=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,p=(e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&p(e,n,t[n]);if(l)for(var n of l(t))c.call(t,n)&&p(e,n,t[n]);return e};const d={title:"Better List Views in React Native",author:"Spencer Ahrens",authorTitle:"Software Engineer at Facebook",authorURL:"https://github.com/sahrens",authorImageURL:"https://avatars1.githubusercontent.com/u/1509831",authorTwitter:"sahrens2012",tags:["engineering"]},m=void 0,h={permalink:"/blog/2017/03/13/better-list-views",source:"@site/blog/2017-03-13-better-list-views.md",title:"Better List Views in React Native",description:"Many of you have started playing with some of our new List components already after our teaser announcement in the community group, but we are officially announcing them today! No more ListViews or DataSources, stale rows, ignored bugs, or excessive memory consumption - with the latest React Native March 2017 release candidate (0.43-rc.1) you can pick from the new suite of components what best fits your use-case, with great perf and feature sets out of the box:",date:"2017-03-13T00:00:00.000Z",formattedDate:"March 13, 2017",tags:[{label:"engineering",permalink:"/blog/tags/engineering"}],readingTime:5.255,truncated:!1,authors:[{name:"Spencer Ahrens",title:"Software Engineer at Facebook",url:"https://github.com/sahrens",imageURL:"https://avatars1.githubusercontent.com/u/1509831"}],prevItem:{title:"React Native Monthly #1",permalink:"/blog/2017/06/21/react-native-monthly-1"},nextItem:{title:"idx: The Existential Function",permalink:"/blog/2017/03/13/idx-the-existential-function"}},f={authorsImageUrls:[void 0]},y=[{value:"<FlatList>",id:"flatlist",children:[],level:3},{value:"<SectionList>",id:"sectionlist",children:[],level:3},{value:"<VirtualizedList>",id:"virtualizedlist",children:[],level:3},{value:"Features",id:"features",children:[{value:"Some Caveats",id:"some-caveats",children:[],level:3}],level:2},{value:"Performance",id:"performance",children:[],level:2},{value:"Advanced Usage",id:"advanced-usage",children:[],level:2},{value:"Future Work",id:"future-work",children:[],level:2}],k={toc:y};function g(e){var t,n=e,{components:r}=n,p=((e,t)=>{var n={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&l)for(var a of l(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},k),p),i(t,o({components:r,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Many of you have started playing with some of our new List components already after our ",(0,a.kt)("a",u({parentName:"p"},{href:"https://www.facebook.com/groups/react.native.community/permalink/921378591331053"}),"teaser announcement in the community group"),", but we are officially announcing them today! No more ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView"),"s or ",(0,a.kt)("inlineCode",{parentName:"p"},"DataSource"),"s, stale rows, ignored bugs, or excessive memory consumption - with the latest React Native March 2017 release candidate (",(0,a.kt)("inlineCode",{parentName:"p"},"0.43-rc.1"),") you can pick from the new suite of components what best fits your use-case, with great perf and feature sets out of the box:"),(0,a.kt)("h3",u({},{id:"flatlist"}),(0,a.kt)("a",u({parentName:"h3"},{href:"/docs/flatlist"}),(0,a.kt)("inlineCode",{parentName:"a"},"<FlatList>"))),(0,a.kt)("p",null,"This is the workhorse component for simple, performant lists. Provide an array of data and a ",(0,a.kt)("inlineCode",{parentName:"p"},"renderItem")," function and you're good to go:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"<FlatList\n  data={[{title: 'Title Text', key: 'item1'}, ...]}\n  renderItem={({item}) => <ListItem title={item.title} />}\n/>\n")),(0,a.kt)("h3",u({},{id:"sectionlist"}),(0,a.kt)("a",u({parentName:"h3"},{href:"/docs/sectionlist"}),(0,a.kt)("inlineCode",{parentName:"a"},"<SectionList>"))),(0,a.kt)("p",null,"If you want to render a set of data broken into logical sections, maybe with section headers (e.g. in an alphabetical address book), and potentially with heterogeneous data and rendering (such as a profile view with some buttons followed by a composer, then a photo grid, then a friend grid, and finally a list of stories), this is the way to go."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"<SectionList\n  renderItem={({item}) => <ListItem title={item.title} />}\n  renderSectionHeader={({section}) => <H1 title={section.key} />}\n  sections={[ // homogeneous rendering between sections\n    {data: [...], key: ...},\n    {data: [...], key: ...},\n    {data: [...], key: ...},\n  ]}\n/>\n\n<SectionList\n  sections={[ // heterogeneous rendering between sections\n    {data: [...], key: ..., renderItem: ...},\n    {data: [...], key: ..., renderItem: ...},\n    {data: [...], key: ..., renderItem: ...},\n  ]}\n/>\n")),(0,a.kt)("h3",u({},{id:"virtualizedlist"}),(0,a.kt)("a",u({parentName:"h3"},{href:"/docs/virtualizedlist"}),(0,a.kt)("inlineCode",{parentName:"a"},"<VirtualizedList>"))),(0,a.kt)("p",null,"The implementation behind the scenes with a more flexible API. Especially handy if your data is not in a plain array (e.g. an immutable list)."),(0,a.kt)("h2",u({},{id:"features"}),"Features"),(0,a.kt)("p",null,"Lists are used in many contexts, so we packed the new components full of features to handle the majority of use cases out of the box:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Scroll loading (",(0,a.kt)("inlineCode",{parentName:"li"},"onEndReached"),")."),(0,a.kt)("li",{parentName:"ul"},"Pull to refresh (",(0,a.kt)("inlineCode",{parentName:"li"},"onRefresh")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"refreshing"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",u({parentName:"li"},{href:"https://github.com/facebook/react-native/blob/master/Libraries/CustomComponents/Lists/ViewabilityHelper.js"}),"Configurable")," viewability (VPV) callbacks (",(0,a.kt)("inlineCode",{parentName:"li"},"onViewableItemsChanged")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"viewabilityConfig"),")."),(0,a.kt)("li",{parentName:"ul"},"Horizontal mode (",(0,a.kt)("inlineCode",{parentName:"li"},"horizontal"),")."),(0,a.kt)("li",{parentName:"ul"},"Intelligent item and section separators."),(0,a.kt)("li",{parentName:"ul"},"Multi-column support (",(0,a.kt)("inlineCode",{parentName:"li"},"numColumns"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"scrollToEnd"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"scrollToIndex"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"scrollToItem")),(0,a.kt)("li",{parentName:"ul"},"Better Flow typing.")),(0,a.kt)("h3",u({},{id:"some-caveats"}),"Some Caveats"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The internal state of item subtrees is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"These components are based on ",(0,a.kt)("inlineCode",{parentName:"p"},"PureComponent")," which means that they will not re-render if ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," remains shallow-equal. Make sure that everything your ",(0,a.kt)("inlineCode",{parentName:"p"},"renderItem")," function depends on directly is passed as a prop that is not ",(0,a.kt)("inlineCode",{parentName:"p"},"===")," after updates, otherwise your UI may not update on changes. This includes the ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," prop and parent component state. For example:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",u({parentName:"pre"},{className:"language-jsx"}),"<FlatList\n  data={this.state.data}\n  renderItem={({ item }) => (\n    <MyItem\n      item={item}\n      onPress={() =>\n        this.setState((oldState) => ({\n          selected: {\n            // New instance breaks `===`\n            ...oldState.selected, // copy old data\n            [item.key]: !oldState.selected[item.key] // toggle\n          }\n        }))\n      }\n      selected={\n        !!this.state.selected[item.key] // renderItem depends on state\n      }\n    />\n  )}\n  selected={\n    // Can be any prop that doesn't collide with existing props\n    this.state.selected // A change to selected should re-render FlatList\n  }\n/>\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate and momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"By default, these new lists look for a ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," prop on each item and use that for the React key. Alternatively, you can provide a custom ",(0,a.kt)("inlineCode",{parentName:"p"},"keyExtractor")," prop."))),(0,a.kt)("h2",u({},{id:"performance"}),"Performance"),(0,a.kt)("p",null,"Besides simplifying the API, the new list components also have significant performance enhancements, the main one being nearly constant memory usage for any number of rows. This is done by 'virtualizing' elements that are outside of the render window by completely unmounting them from the component hierarchy and reclaiming the JS memory from the react components, along with the native memory from the shadow tree and the UI views. This has a catch which is that internal component state will not be preserved, so ",(0,a.kt)("strong",{parentName:"p"},"make sure you track any important state outside of the components themselves, e.g. in Relay or Redux or Flux store.")),(0,a.kt)("p",null,"Limiting the render window also reduces the amount of work that needs to be done by React and the native platform, e.g from view traversals. Even if you are rendering the last of a million elements, with these new lists there is no need to iterate through all those elements in order to render. You can even jump to the middle with ",(0,a.kt)("inlineCode",{parentName:"p"},"scrollToIndex")," without excessive rendering."),(0,a.kt)("p",null,"We've also made some improvements with scheduling which should help with application responsiveness. Items at the edge of the render window are rendered infrequently and at a lower priority after any active gestures or animations or other interactions have completed."),(0,a.kt)("h2",u({},{id:"advanced-usage"}),"Advanced Usage"),(0,a.kt)("p",null,"Unlike ",(0,a.kt)("inlineCode",{parentName:"p"},"ListView"),", all items in the render window are re-rendered any time any props change. Often this is fine because the windowing reduces the number of items to a constant number, but if your items are on the complex side, you should make sure to follow React best practices for performance and use ",(0,a.kt)("inlineCode",{parentName:"p"},"React.PureComponent")," and/or ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldComponentUpdate")," as appropriate within your components to limit re-renders of the recursive subtree."),(0,a.kt)("p",null,"If you can calculate the height of your rows without rendering them, you can improve the user experience by providing the ",(0,a.kt)("inlineCode",{parentName:"p"},"getItemLayout")," prop. This makes it much smoother to scroll to specific items with e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"scrollToIndex"),", and will improve the scroll indicator UI because the height of the content can be determined without rendering it."),(0,a.kt)("p",null,"If you have an alternative data type, like an immutable list, ",(0,a.kt)("inlineCode",{parentName:"p"},"<VirtualizedList>")," is the way to go. It takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"getItem")," prop that lets you return the item data for any given index and has looser flow typing."),(0,a.kt)("p",null,"There are also a bunch of parameters you can tweak if you have an unusual use case. For example, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"windowSize")," to trade off memory usage vs. user experience, ",(0,a.kt)("inlineCode",{parentName:"p"},"maxToRenderPerBatch")," to adjust fill rate vs. responsiveness, ",(0,a.kt)("inlineCode",{parentName:"p"},"onEndReachedThreshold")," to control when scroll loading happens, and more."),(0,a.kt)("h2",u({},{id:"future-work"}),"Future Work"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Migration of existing surfaces (ultimately deprecation of ",(0,a.kt)("inlineCode",{parentName:"li"},"ListView"),")."),(0,a.kt)("li",{parentName:"ul"},"More features as we see/hear the need (let us know!)."),(0,a.kt)("li",{parentName:"ul"},"Sticky section header support."),(0,a.kt)("li",{parentName:"ul"},"More performance optimizations."),(0,a.kt)("li",{parentName:"ul"},"Support functional item components with state.")))}g.isMDXComponent=!0}}]);